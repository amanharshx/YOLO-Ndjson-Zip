use super::{get_class_list, get_class_names, Converter};
use crate::parser::{image_download_key, ImageEntry, NDJSONData};
use std::collections::HashMap;

pub struct YoloConverter {
    darknet: bool,
}

fn quote_yaml_scalar(value: &str) -> String {
    serde_json::to_string(value).unwrap_or_else(|_| "\"\"".to_string())
}

fn sanitize_path_segment(segment: &str) -> String {
    let sanitized = segment
        .chars()
        .map(|c| match c {
            '/' | '\\' | '\0' => '_',
            _ => c,
        })
        .collect::<String>()
        .trim()
        .to_string();

    if sanitized.is_empty() {
        "unlabeled".to_string()
    } else {
        sanitized
    }
}

impl YoloConverter {
    pub fn new() -> Self {
        Self { darknet: false }
    }

    pub fn new_darknet() -> Self {
        Self { darknet: true }
    }

    fn create_data_yaml(&self, data: &NDJSONData) -> String {
        let class_names = get_class_list(data);
        let task = &data.metadata.task;

        let mut yaml = String::new();
        yaml.push_str("# Generated by YOLO NDJSON Converter\n");
        yaml.push_str(&format!("# Version: {}\n", env!("CARGO_PKG_VERSION")));
        yaml.push_str("# https://github.com/amanharshx/YOLO-Ndjson-Zip\n\n");
        yaml.push_str("path: .\n");
        yaml.push_str("train: train/images\n");
        yaml.push_str("val: valid/images\n");
        yaml.push_str("test: test/images\n");
        yaml.push_str(&format!("nc: {}\n", class_names.len()));
        yaml.push_str("names:\n");

        for (i, name) in class_names.iter().enumerate() {
            yaml.push_str(&format!("  {}: {}\n", i, quote_yaml_scalar(name)));
        }

        if task == "pose" {
            if let Some(kpt_shape) = &data.metadata.kpt_shape {
                yaml.push_str(&format!(
                    "kpt_shape: [{}, {}]\n",
                    kpt_shape[0],
                    kpt_shape.get(1).unwrap_or(&2)
                ));
            }
        }

        yaml
    }

    fn create_detection_label(&self, img: &ImageEntry) -> String {
        img.get_bboxes()
            .iter()
            .map(|bbox| {
                format!(
                    "{} {:.6} {:.6} {:.6} {:.6}",
                    bbox.class_id, bbox.x, bbox.y, bbox.width, bbox.height
                )
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn create_pose_label(&self, img: &ImageEntry, kpt_shape: Option<&[i32]>) -> String {
        img.get_pose_annotations(kpt_shape)
            .iter()
            .map(|pose| {
                let mut parts = vec![
                    pose.class_id.to_string(),
                    format!("{:.6}", pose.bbox_x),
                    format!("{:.6}", pose.bbox_y),
                    format!("{:.6}", pose.bbox_w),
                    format!("{:.6}", pose.bbox_h),
                ];

                for (kp_x, kp_y) in &pose.keypoints {
                    let visibility = if *kp_x > 0.0 || *kp_y > 0.0 { 2 } else { 0 };
                    parts.push(format!("{:.6}", kp_x));
                    parts.push(format!("{:.6}", kp_y));
                    parts.push(visibility.to_string());
                }

                parts.join(" ")
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn create_segment_label(&self, img: &ImageEntry) -> String {
        img.get_segment_annotations()
            .iter()
            .map(|seg| {
                let mut parts = vec![seg.class_id.to_string()];
                for (x, y) in &seg.points {
                    parts.push(format!("{:.6}", x));
                    parts.push(format!("{:.6}", y));
                }
                parts.join(" ")
            })
            .collect::<Vec<_>>()
            .join("\n")
    }
}

impl Converter for YoloConverter {
    fn convert(
        &self,
        data: &NDJSONData,
        downloaded_images: &HashMap<String, Vec<u8>>,
    ) -> HashMap<String, Vec<u8>> {
        let mut files: HashMap<String, Vec<u8>> = HashMap::new();
        let task = &data.metadata.task;

        if self.darknet {
            // Darknet mode: _darknet.labels instead of data.yaml/classes.txt
            let class_list = get_class_list(data);
            files.insert(
                "_darknet.labels".to_string(),
                class_list.join("\n").into_bytes(),
            );
        } else {
            // Standard YOLO mode
            files.insert(
                "data.yaml".to_string(),
                self.create_data_yaml(data).into_bytes(),
            );
            let class_list = get_class_list(data);
            files.insert(
                "classes.txt".to_string(),
                class_list.join("\n").into_bytes(),
            );
        }

        let kpt_shape = data.metadata.kpt_shape.as_deref();

        // Process images by split
        let splits = [
            ("train", data.train_images()),
            ("valid", data.valid_images()),
            ("test", data.test_images()),
        ];

        for (split, images) in splits {
            for img in images {
                let image_file = img.effective_file_name();
                // Create label file
                let label_content = match task.as_str() {
                    "pose" => self.create_pose_label(img, kpt_shape),
                    "segment" => self.create_segment_label(img),
                    "classify" => {
                        // For classification, we use folder structure
                        let classifications = img.get_classifications();
                        if let Some(&class_id) = classifications.first() {
                            let class_names = get_class_names(data);
                            let class_name = class_names
                                .get(&class_id)
                                .cloned()
                                .unwrap_or_else(|| format!("class_{}", class_id));
                            let class_dir = sanitize_path_segment(&class_name);

                            if let Some(image_data) =
                                downloaded_images.get(&image_download_key(split, image_file))
                            {
                                files.insert(
                                    format!("{}/{}/{}", split, class_dir, image_file),
                                    image_data.clone(),
                                );
                            }
                        }
                        continue;
                    }
                    _ => self.create_detection_label(img),
                };

                let label_filename = img
                    .effective_file_name()
                    .rsplit_once('.')
                    .map(|(name, _)| name)
                    .unwrap_or(image_file);

                if self.darknet {
                    // Darknet: flat structure, images + labels side by side in {split}/
                    files.insert(
                        format!("{}/{}.txt", split, label_filename),
                        label_content.into_bytes(),
                    );
                    if let Some(image_data) =
                        downloaded_images.get(&image_download_key(split, image_file))
                    {
                        files.insert(format!("{}/{}", split, image_file), image_data.clone());
                    }
                } else {
                    // Standard YOLO: {split}/labels/ and {split}/images/
                    files.insert(
                        format!("{}/labels/{}.txt", split, label_filename),
                        label_content.into_bytes(),
                    );
                    if let Some(image_data) =
                        downloaded_images.get(&image_download_key(split, image_file))
                    {
                        files.insert(
                            format!("{}/images/{}", split, image_file),
                            image_data.clone(),
                        );
                    }
                }
            }
        }

        files
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::{image_download_key, DatasetMetadata, ImageEntry, NDJSONData};
    use serde_json::json;

    fn make_data(
        task: &str,
        class_names: HashMap<String, String>,
        kpt_shape: Option<Vec<i32>>,
        images: Vec<ImageEntry>,
    ) -> NDJSONData {
        NDJSONData {
            metadata: DatasetMetadata {
                r#type: "dataset".to_string(),
                task: task.to_string(),
                name: "test".to_string(),
                description: String::new(),
                bytes: 0,
                url: String::new(),
                class_names,
                kpt_shape,
                version: 1,
            },
            images,
        }
    }

    #[test]
    fn create_data_yaml_quotes_class_names() {
        let mut class_names = HashMap::new();
        class_names.insert("0".to_string(), "cat: {evil: true}\n# injected".to_string());
        let data = make_data("detect", class_names, None, vec![]);
        let converter = YoloConverter::new();

        let yaml = converter.create_data_yaml(&data);

        assert!(yaml.contains(r#"0: "cat: {evil: true}\n# injected""#));
    }

    #[test]
    fn classify_paths_sanitize_class_name_segments() {
        let mut class_names = HashMap::new();
        class_names.insert("0".to_string(), "dogs/cats".to_string());
        let image = ImageEntry {
            r#type: "image".to_string(),
            file: "img1.jpg".to_string(),
            output_file: None,
            url: String::new(),
            width: 640,
            height: 480,
            split: "train".to_string(),
            annotations: Some(json!({
                "classification": [0]
            })),
        };
        let data = make_data("classify", class_names, None, vec![image]);
        let converter = YoloConverter::new();
        let mut downloaded_images = HashMap::new();
        downloaded_images.insert(image_download_key("train", "img1.jpg"), vec![1, 2, 3]);

        let files = converter.convert(&data, &downloaded_images);

        assert!(files.contains_key("train/dogs_cats/img1.jpg"));
    }

    #[test]
    fn convert_uses_split_aware_download_keys() {
        let mut class_names = HashMap::new();
        class_names.insert("0".to_string(), "animal".to_string());

        let train_image = ImageEntry {
            r#type: "image".to_string(),
            file: "img1.jpg".to_string(),
            output_file: None,
            url: String::new(),
            width: 640,
            height: 480,
            split: "train".to_string(),
            annotations: Some(json!({
                "bboxes": [[0, 0.5, 0.5, 0.2, 0.2]]
            })),
        };
        let valid_image = ImageEntry {
            r#type: "image".to_string(),
            file: "img1.jpg".to_string(),
            output_file: None,
            url: String::new(),
            width: 640,
            height: 480,
            split: "val".to_string(),
            annotations: Some(json!({
                "bboxes": [[0, 0.4, 0.4, 0.3, 0.3]]
            })),
        };

        let data = make_data("detect", class_names, None, vec![train_image, valid_image]);
        let converter = YoloConverter::new();
        let mut downloaded_images = HashMap::new();
        downloaded_images.insert(image_download_key("train", "img1.jpg"), vec![1]);
        downloaded_images.insert(image_download_key("valid", "img1.jpg"), vec![2]);

        let files = converter.convert(&data, &downloaded_images);

        assert_eq!(files.get("train/images/img1.jpg"), Some(&vec![1]));
        assert_eq!(files.get("valid/images/img1.jpg"), Some(&vec![2]));
    }

    #[test]
    fn convert_uses_effective_file_names_for_duplicate_outputs() {
        let mut class_names = HashMap::new();
        class_names.insert("0".to_string(), "heic".to_string());
        class_names.insert("1".to_string(), "png".to_string());

        let data = make_data(
            "detect",
            class_names,
            None,
            vec![
                ImageEntry {
                    r#type: "image".to_string(),
                    file: "Frame_98.jpg".to_string(),
                    output_file: None,
                    url: "https://cdn.example/a.jpg".to_string(),
                    width: 640,
                    height: 480,
                    split: "train".to_string(),
                    annotations: Some(json!({
                        "boxes": [[0, 0.5, 0.5, 0.2, 0.2]]
                    })),
                },
                ImageEntry {
                    r#type: "image".to_string(),
                    file: "Frame_98.jpg".to_string(),
                    output_file: Some("Frame_98__abcd1234.jpg".to_string()),
                    url: "https://cdn.example/b.jpg".to_string(),
                    width: 640,
                    height: 480,
                    split: "train".to_string(),
                    annotations: Some(json!({
                        "boxes": [[1, 0.4, 0.4, 0.3, 0.3]]
                    })),
                },
            ],
        );

        let converter = YoloConverter::new();
        let mut downloaded_images = HashMap::new();
        downloaded_images.insert(image_download_key("train", "Frame_98.jpg"), vec![1]);
        downloaded_images.insert(
            image_download_key("train", "Frame_98__abcd1234.jpg"),
            vec![2],
        );

        let files = converter.convert(&data, &downloaded_images);

        assert_eq!(files.get("train/images/Frame_98.jpg"), Some(&vec![1]));
        assert_eq!(
            files.get("train/images/Frame_98__abcd1234.jpg"),
            Some(&vec![2])
        );
        assert!(files.contains_key("train/labels/Frame_98.txt"));
        assert!(files.contains_key("train/labels/Frame_98__abcd1234.txt"));
    }
}
